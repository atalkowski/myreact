<html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway"> -->
<head>
  <title>GitOps and Kubernetes</title>
  <link rel="stylesheet" href="../css/v1.css">
  <script src="../js/utils.js"></script>
</head>
<body class="w3-light-grey"">
<div class="w3-content" style="max-width:1400px">
<div class="myhtml">
<h2>What is GitOps?</h2>
<p>GitOps uses Git repositories as a single source of truth to deliver infrastructure as code.
  Submitted code checks the CI process, while the CD process checks and applies requirements for things like security,
  infrastructure as code, or any other boundaries set for the application framework. 
  All changes to code are tracked, making updates easy while also providing version control should a rollback be needed.</p>
<h3>GitOps delivers:</h3>
<ul>
 <li>A standard workflow for application development</li>
 <li>Increased security for setting application requirements upfront</li>
 <li>Improved reliability with visibility and version control through Git</li>
 <li>Consistency across any cluster, any cloud, and any on premise environment</li>
 <li>By using the same Git-based workflows that developers are familiar with, GitOps expands upon existing processes from application development to deployment, application life cycle management, and infrastructure configuration:</li>
 <li>For developers, they can now code at their own pace without waiting on resources to be assigned or approved by operations teams.</li>
 <li>For ops teams, visibility to change means the ability to trace and reproduce issues quickly, improving overall security.</li>
 <li>For organizations, with an up-to-date audit trail they can reduce the risk of unwanted changes and correct them before they go into production.</li>
 <li>Using platforms of QA, Stage and Prod we can try solutions and infrastructure/ops updates in a systematic and controlled way.</li>
</ul>
<h3>Using GitOps</h3>
<p>To use GitOps we need infrastructure that can be declaratively managed.
  Because of this, GitOps is often used as an operating model for Kubernetes and cloud-native application development
  and can enable continuous deployment for Kubernetes.
</p>
<h3>What is Kubernetes?</h3>
<p>Kubernetes (also known as k8s or " kube ”) is an
   <a href="https://www.redhat.com/en/topics/open-source/what-is-open-source">open source</a>
   <b>container orchestration platform</b>
that automates many of the manual processes involved in deploying, managing, and
scaling containerized applications. See detail in appendix: Kubernetes Steps
and https://www.redhat.com/en/topics/containers/what-is-kubernetes. 
You can cluster together groups of hosts running Linux® <a href="https://www.redhat.com/en/topics/containers">containers</a>,
and Kubernetes helps you easily and efficiently manage those clusters. See also <b><i> ArgoCD</i></b> below.
</p>
<p><a href="https://www.redhat.com/en/topics/containers/what-is-a-kubernetes-cluster">Kubernetes clusters</a> can span hosts across on-premise, 
 <a href="https://www.redhat.com/en/topics/cloud-computing/what-is-public-cloud"> public</a>,
 <a href="https://www.redhat.com/en/topics/cloud-computing/what-is-private-cloud">private </a>, or 
 <a href="https://www.redhat.com/en/topics/cloud-computing/what-is-hybrid-cloud">hybrid clouds</a>.
For this reason, Kubernetes is an ideal platform for hosting 
  <a href="https://www.redhat.com/en/topics/cloud-native-apps">cloud-native applications</a>
 that require rapid scaling (like real-time data streaming through 
  <a href="https://www.redhat.com/en/topics/integration/what-is-apache-kafka"> Apache Kafka </a>.
Note though we have seen some abrasion between Kafka and AWS cloud services –
we need to investigate. It was probably dopey implementation but beware. See more later.
</p>
<h3>Kubernetes dependencies</h3>
<p>Kubernetes relies on other projects to fully provide these orchestrated services.
With the addition of other open source projects, you can fully realize the power of Kubernetes.
These necessary pieces include (among others):
</p>
<ul>
 <li>Registry, through projects like Docker Registry.</li>
 <li>Networking, through projects like OpenvSwitch and intelligent edge routing.</li>
 <li>Telemetry, through projects such as Kibana, Hawkular, and Elastic.</li>
 <li>Security, through projects like LDAP, SELinux, RBAC, and OAUTH with multitenancy layers.</li>
 <li>Automation, with the addition of Ansible playbooks for installation and cluster life cycle management.</li>
 <li>Services, through a rich catalog of popular app patterns.</li>
</ul>
<h3>Argo CD</h3>
Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. What it brings:
<ul>
 <li>Application definitions, configurations, and environments should be declarative and version controlled. </li>
 <li>Application deployment and lifecycle management should be automated, auditable, and easy to understand.</li>
 <li>A nice user friendly Web UI onto the deployments pods and configuration components, allowing restarts, inspection etc etc.</li>
</ul>
<h3>How Argo CD works</h3>
Argo CD follows the GitOps pattern of using Git repositories as the source of truth for defining the desired application state.
<br/>Kubernetes manifests can be specified in several ways:
<ul>
  <li>kustomize applications</li>
  <li>helm charts</li>
  <li>jsonnet files</li>
  <li>Plain directory of YAML/json manifests</li>
  <li>Any custom config management tool configured as a config management plugin</li>
  <li>Argo CD automates the deployment of the desired application states in the specified target environments.</li>
  <li>Application deployments can track updates to branches, tags, or pinned to a specific version of manifests at a Git commit.</li>
  <li>See tracking strategies for additional details about the different tracking strategies available.</li>
</ul>
<h3>Quick Start</h3>
<ul>
 <li>kubectl create namespace argocd</li>
 <li>kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml</li>
 <li>See also the <a href="https://argo-cd.readthedocs.io/en/stable/getting_started/">getting started guide</a>. </li>
 <li>And the <a href="https://argo-cd.readthedocs.io/en/stable/user-guide/">user oriented</a> documentation and upgrade guide.</li>
 <li>On Mac: <span class="code"> brew install argocd</span></li>
</ul>
<h3>ArgoCD vs Jenkins vs Terraform</h3>
<ul>
<li><b>Jenkins</b> is a more traditional automation server that is suitable for a wide range of applications.</li>
<li><b>ArgoCD</b> is designed specifically for Kubernetes environments.</li>
<li><b>Terraform</b> is very useful for automating infrastructure - especially for repetitive variants and contorl over CLOUD based infrastructure such as AWS SNS and SQS</li>
<li>On the other hand, <b>ArgoCD</b> helps us implement GitOps and continuous delivery for our applications.</li>
<li>We can successfully combine <b>ArgoCD</b> and <b>Terraform</b>: Argo taking care of K8S deployments and Terraform for (AWS) infrastructure updates.</li>
</ul>
<h3>Helm charts.</h3>
Install with:
 <span cass=""code2">brew install helm.</span>
<p>For Helm, there are three important concepts:</p>
<ul>
 <li>The chart is a bundle of information necessary to create an instance of a Kubernetes application.</li>
 <li>The config contains configuration information that can be merged into a packaged chart to create a releasable object.</li>
 <li>A release is a running instance of a chart, combined with a specific config.</li>
</ul>
<h4>Helm Implementation</h4>
<ul>
 <li>The Helm client and library is written in the Go programming language.</li>
 <li>The library uses the Kubernetes client library to communicate with Kubernetes.</li>
 <li>Currently, that library uses REST+JSON. It stores information in Secrets located inside of Kubernetes.</li>
 <li>It does not need its own database.</li>
 <li>Configuration files are, when possible, written in YAML.</li>
 <li>See <a href="https://helm.sh/docs">https://helm.sh/docs</a> for further info.</li>
</ul>
<h3>Kubernetes goals.</h3>
<p>The primary advantage of using Kubernetes in your environment, especially if you are optimizing app dev for the cloud, is that it gives you the platform to schedule and run containers on clusters of physical or virtual machines (VMs).
  More broadly, it helps you fully implement and rely on a container-based infrastructure in production environments. And because Kubernetes is all about automation of operational tasks, you can do many of the same things other application platforms or management systems let you do—but for your containers.
  Developers can also create cloud-native apps with Kubernetes as a runtime platform by using Kubernetes patterns. Patterns are the tools a Kubernetes developer needs to build container-based applications and services.
</p>
<ul>
 <li>Orchestrate containers across multiple hosts.</li>
 <li>Make better use of hardware to maximize resources needed to run your enterprise apps.</li>
 <li>Control and automate application deployments and updates.</li>
 <li>Mount and add storage to run stateful apps.</li>
 <li>Scale containerized applications and their resources on the fly.</li>
 <li>Declaratively manage services, which guarantees the deployed applications are always running the way you intended them to run.</li>
 <li>Health-check and self-heal your apps with autoplacement, autorestart, autoreplication, and autoscaling.</li>
</ul>
<h2>Appendix: IaaS, PaaS and SaaS.</h2>
IaaS – Infrastructure as a Service - model used by network architects - providing virtualized computing resources over the internet. It gives access to the resources like virtual machines and virtual storage – tech knowledge required.
PaaS – Platform as a Service – model used by developers, a cloud computing model that delivers tools for the development of applications – such as AWS Services platform for RDS, SQS etc. It allows access to a run time environment for deployment and use of development tools – tech knowledge is required.
SaaS – Software as a Service – model used by end user clients, a cloud computing model that hosts software (as developed by the vendor) to make it available to clients (the users). No technical knowledge is required by consumer – all provided by the SaaS company.
<h2>Appendix : Pipeline example</h2>
<p>This was a work in progress, not fully automated. And maybe necessarily so to enusre we needed a human in the flow to permit releases.
</p>
Pipeline were affected by the switch from Jenkins to AWS CodeBuild to GitLab.
We used the following process for managing CI/CD at HF.
<ul>
<li><b>Stage 1: Get a basic service built:</b>
  <ul>
    <li>Using (say) Java + Spring Boot and embedded Tomcat</li>
    <li>Use Maven build</li>
    <li>Use Artifactory repositories for dependencies and code libs</li>
    <li>All original source code stored in a specific GIT repo.</li>
    <li>Auto or manual updates to Artifactory repo may be required.</li>
    <li>Output of stage 1 will be repo of all the service’s source code above in GIT and jar or war updated to Artifactory.</li>
  </ul>
  </li>
<li><b>Stage 2: Containerize the app/service as a docker image:</b>
  <ul>
    <li>Use Dockerfile to define how the docker image is built.</li>
    <li>Use of makefile and make for other needs e.g. local launch/test</li>
    <li>Added to the same GIT repo as above.</li>
    <li>Output of stage 2 will be docker versioned images held in a dedicated REPO.</li>
  </ul>
</li>
<li><b>Stage 3: Setup/update Kubernetes Namespace for the app/service.</b>
  <ul>
    <li>Use a separate dedicated repo for all K8s config manifests Yaml files.</li>
    <li>The service will use its own special subdirectory within that repo:</li>
    <li>Deeper subdirs will define platform specifics: e.g. QA, stage, production giving us multiple release candidates for each App/Svc.</li>
    <li>This structure allows us to define platform specific namespaces that are version controlled and will be managed by K8s</li>
    <li>The K8s application/implementation will constantly use the repo state as it definition of what should be deployed:</li>
    <li>The configs will define replica counts, image versions, settings.</li>
    <li>Scripts then used to help manage the image versions updates with ease.</li>
    <li>Output of stage 3 will be a repo representing the desired state of K8s cluster(s).</li>
  </ul>
</li>
<li><b>Stage 4: Use Argo CD to act as the continuous K8s delivery tool</b>
  <ul>
    <li>We created the namespace argocd and install stable Argo CD in it.</li>
    <li>See <a href="https://argo-cd.readthedocs.io/en/stable/getting_started/">https://argo-cd.readthedocs.io/en/stable/getting_started/</a>"</li>
    <li>This repo is then capable of setting being deployed in kubernetes using the installation instructions to act as a bootstrap for out cluster.</li>
    <li>Output of stage 4 is a working K8s using from gitops repo for all our ns/pods.</li>
  </ul>
</li>
<li><b>Stage 5: Maintaining AWS configurations.</b>
  <ul>
    <li>A separate repo was used to maintain the AWS dependencies / configs.</li>
    <li>We used Terraform (and Terragrunt) to manage these updates.</li>
    <li>AWS specific definitions are held in YAML files (and Helm?).</li>
    <li>Terraform will check the AWS state and manage updates as required.</li>
  </ul>
</li>  
</ul>

<h3>What about Gitab?</h3>
The conversion from Jenkins then AWS CodeCommit/Build to Gitlab was still a work in progress on many projects.
<h3>Useful links</h3>
<ul>
  <li><a href="https://www.fosstechnix.com/gitops-with-argocd-pipeline">ArgoCD Pipeline</a></li>
</ul>
</div>
</div> <!-- End of the main content -->
</body>
</html>
